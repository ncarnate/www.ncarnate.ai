/*!
 * ScrollTrigger 3.12.4
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/import{Observer,_getTarget,_vertical,_horizontal,_scrollers,_proxies,_getScrollFunc,_getProxyProp,_getVelocityProp}from"./Observer.js";let gsap,_coreInitted,_win,_doc,_docEl,_body,_root,_resizeDelay,_toArray,_clamp,_time2,_syncInterval,_refreshing,_pointerIsDown,_transformProp,_i,_prevWidth,_prevHeight,_autoRefresh,_sort,_suppressOverwrites,_ignoreResize,_normalizer,_ignoreMobileResize,_baseScreenHeight,_baseScreenWidth,_fixIOSBug,_context,_scrollRestoration,_div100vh,_100vh,_isReverted,_clampingMax,_limitCallbacks,_startup=1,_getTime=Date.now,_time1=_getTime(),_lastScrollTime=0,_enabled=0,_parseClamp=(value,type,self)=>{let clamp=_isString(value)&&(value.substr(0,6)==="clamp("||value.indexOf("max")>-1);return self["_"+type+"Clamp"]=clamp,clamp?value.substr(6,value.length-7):value},_keepClamp=(value,clamp)=>clamp&&(!_isString(value)||value.substr(0,6)!=="clamp(")?"clamp("+value+")":value,_rafBugFix=()=>_enabled&&requestAnimationFrame(_rafBugFix),_pointerDownHandler=()=>_pointerIsDown=1,_pointerUpHandler=()=>_pointerIsDown=0,_passThrough=v=>v,_round=value=>Math.round(value*1e5)/1e5||0,_windowExists=()=>typeof window!="undefined",_getGSAP=()=>gsap||_windowExists()&&(gsap=window.gsap)&&gsap.registerPlugin&&gsap,_isViewport=e=>!!~_root.indexOf(e),_getViewportDimension=dimensionProperty=>(dimensionProperty==="Height"?_100vh:_win["inner"+dimensionProperty])||_docEl["client"+dimensionProperty]||_body["client"+dimensionProperty],_getBoundsFunc=element=>_getProxyProp(element,"getBoundingClientRect")||(_isViewport(element)?()=>(_winOffsets.width=_win.innerWidth,_winOffsets.height=_100vh,_winOffsets):()=>_getBounds(element)),_getSizeFunc=(scroller,isViewport,{d,d2,a})=>(a=_getProxyProp(scroller,"getBoundingClientRect"))?()=>a()[d]:()=>(isViewport?_getViewportDimension(d2):scroller["client"+d2])||0,_getOffsetsFunc=(element,isViewport)=>!isViewport||~_proxies.indexOf(element)?_getBoundsFunc(element):()=>_winOffsets,_maxScroll=(element,{s,d2,d,a})=>Math.max(0,(s="scroll"+d2)&&(a=_getProxyProp(element,s))?a()-_getBoundsFunc(element)()[d]:_isViewport(element)?(_docEl[s]||_body[s])-_getViewportDimension(d2):element[s]-element["offset"+d2]),_iterateAutoRefresh=(func,events)=>{for(let i=0;i<_autoRefresh.length;i+=3)(!events||~events.indexOf(_autoRefresh[i+1]))&&func(_autoRefresh[i],_autoRefresh[i+1],_autoRefresh[i+2])},_isString=value=>typeof value=="string",_isFunction=value=>typeof value=="function",_isNumber=value=>typeof value=="number",_isObject=value=>typeof value=="object",_endAnimation=(animation,reversed,pause)=>animation&&animation.progress(reversed?0:1)&&pause&&animation.pause(),_callback=(self,func)=>{if(self.enabled){let result=self._ctx?self._ctx.add(()=>func(self)):func(self);result&&result.totalTime&&(self.callbackAnimation=result)}},_abs=Math.abs,_left="left",_top="top",_right="right",_bottom="bottom",_width="width",_height="height",_Right="Right",_Left="Left",_Top="Top",_Bottom="Bottom",_padding="padding",_margin="margin",_Width="Width",_Height="Height",_px="px",_getComputedStyle=element=>_win.getComputedStyle(element),_makePositionable=element=>{let position=_getComputedStyle(element).position;element.style.position=position==="absolute"||position==="fixed"?position:"relative"},_setDefaults=(obj,defaults)=>{for(let p in defaults)p in obj||(obj[p]=defaults[p]);return obj},_getBounds=(element,withoutTransforms)=>{let tween=withoutTransforms&&_getComputedStyle(element)[_transformProp]!=="matrix(1, 0, 0, 1, 0, 0)"&&gsap.to(element,{x:0,y:0,xPercent:0,yPercent:0,rotation:0,rotationX:0,rotationY:0,scale:1,skewX:0,skewY:0}).progress(1),bounds=element.getBoundingClientRect();return tween&&tween.progress(0).kill(),bounds},_getSize=(element,{d2})=>element["offset"+d2]||element["client"+d2]||0,_getLabelRatioArray=timeline=>{let a=[],labels=timeline.labels,duration=timeline.duration(),p;for(p in labels)a.push(labels[p]/duration);return a},_getClosestLabel=animation=>value=>gsap.utils.snap(_getLabelRatioArray(animation),value),_snapDirectional=snapIncrementOrArray=>{let snap=gsap.utils.snap(snapIncrementOrArray),a=Array.isArray(snapIncrementOrArray)&&snapIncrementOrArray.slice(0).sort((a,b)=>a-b);return a?(value,direction,threshold=.001)=>{let i;if(!direction)return snap(value);if(direction>0){value-=threshold;for(i=0;i<a.length;i++)if(a[i]>=value)return a[i];return a[i-1]}for(i=a.length,value+=threshold;i--;)if(a[i]<=value)return a[i];return a[0]}:(value,direction,threshold=.001)=>{let snapped=snap(value);return!direction||Math.abs(snapped-value)<threshold||snapped-value<0===direction<0?snapped:snap(direction<0?value-snapIncrementOrArray:value+snapIncrementOrArray)}},_getLabelAtDirection=timeline=>(value,st)=>_snapDirectional(_getLabelRatioArray(timeline))(value,st.direction),_multiListener=(func,element,types,callback)=>types.split(",").forEach(type=>func(element,type,callback)),_addListener=(element,type,func,nonPassive,capture)=>element.addEventListener(type,func,{passive:!nonPassive,capture:!!capture}),_removeListener=(element,type,func,capture)=>element.removeEventListener(type,func,!!capture),_wheelListener=(func,el,scrollFunc)=>{scrollFunc=scrollFunc&&scrollFunc.wheelHandler,scrollFunc&&(func(el,"wheel",scrollFunc),func(el,"touchmove",scrollFunc))},_markerDefaults={startColor:"green",endColor:"red",indent:0,fontSize:"16px",fontWeight:"normal"},_defaults={toggleActions:"play",anticipatePin:0},_keywords={top:0,left:0,center:.5,bottom:1,right:1},_offsetToPx=(value,size)=>{if(_isString(value)){let eqIndex=value.indexOf("="),relative=~eqIndex?+(value.charAt(eqIndex-1)+1)*parseFloat(value.substr(eqIndex+1)):0;~eqIndex&&(value.indexOf("%")>eqIndex&&(relative*=size/100),value=value.substr(0,eqIndex-1)),value=relative+(value in _keywords?_keywords[value]*size:~value.indexOf("%")?parseFloat(value)*size/100:parseFloat(value)||0)}return value},_createMarker=(type,name,container,direction,{startColor,endColor,fontSize,indent,fontWeight},offset,matchWidthEl,containerAnimation)=>{let e=_doc.createElement("div"),useFixedPosition=_isViewport(container)||_getProxyProp(container,"pinType")==="fixed",isScroller=type.indexOf("scroller")!==-1,parent=useFixedPosition?_body:container,isStart=type.indexOf("start")!==-1,color=isStart?startColor:endColor,css="border-color:"+color+";font-size:"+fontSize+";color:"+color+";font-weight:"+fontWeight+";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";return css+="position:"+((isScroller||containerAnimation)&&useFixedPosition?"fixed;":"absolute;"),(isScroller||containerAnimation||!useFixedPosition)&&(css+=(direction===_vertical?_right:_bottom)+":"+(offset+parseFloat(indent))+"px;"),matchWidthEl&&(css+="box-sizing:border-box;text-align:left;width:"+matchWidthEl.offsetWidth+"px;"),e._isStart=isStart,e.setAttribute("class","gsap-marker-"+type+(name?" marker-"+name:"")),e.style.cssText=css,e.innerText=name||name===0?type+"-"+name:type,parent.children[0]?parent.insertBefore(e,parent.children[0]):parent.appendChild(e),e._offset=e["offset"+direction.op.d2],_positionMarker(e,0,direction,isStart),e},_positionMarker=(marker,start,direction,flipped)=>{let vars={display:"block"},side=direction[flipped?"os2":"p2"],oppositeSide=direction[flipped?"p2":"os2"];marker._isFlipped=flipped,vars[direction.a+"Percent"]=flipped?-100:0,vars[direction.a]=flipped?"1px":0,vars["border"+side+_Width]=1,vars["border"+oppositeSide+_Width]=0,vars[direction.p]=start+"px",gsap.set(marker,vars)},_triggers=[],_ids={},_rafID,_sync=()=>_getTime()-_lastScrollTime>34&&(_rafID||(_rafID=requestAnimationFrame(_updateAll))),_onScroll=()=>{(!_normalizer||!_normalizer.isPressed||_normalizer.startX>_body.clientWidth)&&(_scrollers.cache++,_normalizer?_rafID||(_rafID=requestAnimationFrame(_updateAll)):_updateAll(),_lastScrollTime||_dispatch("scrollStart"),_lastScrollTime=_getTime())},_setBaseDimensions=()=>{_baseScreenWidth=_win.innerWidth,_baseScreenHeight=_win.innerHeight},_onResize=()=>{_scrollers.cache++,!_refreshing&&!_ignoreResize&&!_doc.fullscreenElement&&!_doc.webkitFullscreenElement&&(!_ignoreMobileResize||_baseScreenWidth!==_win.innerWidth||Math.abs(_win.innerHeight-_baseScreenHeight)>_win.innerHeight*.25)&&_resizeDelay.restart(!0)},_listeners={},_emptyArray=[],_softRefresh=()=>_removeListener(ScrollTrigger,"scrollEnd",_softRefresh)||_refreshAll(!0),_dispatch=type=>_listeners[type]&&_listeners[type].map(f=>f())||_emptyArray,_savedStyles=[],_revertRecorded=media=>{for(let i=0;i<_savedStyles.length;i+=5)(!media||_savedStyles[i+4]&&_savedStyles[i+4].query===media)&&(_savedStyles[i].style.cssText=_savedStyles[i+1],_savedStyles[i].getBBox&&_savedStyles[i].setAttribute("transform",_savedStyles[i+2]||""),_savedStyles[i+3].uncache=1)},_revertAll=(kill,media)=>{let trigger;for(_i=0;_i<_triggers.length;_i++)trigger=_triggers[_i],trigger&&(!media||trigger._ctx===media)&&(kill?trigger.kill(1):trigger.revert(!0,!0));_isReverted=!0,media&&_revertRecorded(media),media||_dispatch("revert")},_clearScrollMemory=(scrollRestoration,force)=>{_scrollers.cache++,(force||!_refreshingAll)&&_scrollers.forEach(obj=>_isFunction(obj)&&obj.cacheID++&&(obj.rec=0)),_isString(scrollRestoration)&&(_win.history.scrollRestoration=_scrollRestoration=scrollRestoration)},_refreshingAll,_refreshID=0,_queueRefreshID,_queueRefreshAll=()=>{if(_queueRefreshID!==_refreshID){let id=_queueRefreshID=_refreshID;requestAnimationFrame(()=>id===_refreshID&&_refreshAll(!0))}},_refresh100vh=()=>{_body.appendChild(_div100vh),_100vh=!_normalizer&&_div100vh.offsetHeight||_win.innerHeight,_body.removeChild(_div100vh)},_hideAllMarkers=hide=>_toArray(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(el=>el.style.display=hide?"none":"block"),_refreshAll=(force,skipRevert)=>{if(_lastScrollTime&&!force&&!_isReverted){_addListener(ScrollTrigger,"scrollEnd",_softRefresh);return}_refresh100vh(),_refreshingAll=ScrollTrigger.isRefreshing=!0,_scrollers.forEach(obj=>_isFunction(obj)&&++obj.cacheID&&(obj.rec=obj()));let refreshInits=_dispatch("refreshInit");_sort&&ScrollTrigger.sort(),skipRevert||_revertAll(),_scrollers.forEach(obj=>{_isFunction(obj)&&(obj.smooth&&(obj.target.style.scrollBehavior="auto"),obj(0))}),_triggers.slice(0).forEach(t=>t.refresh()),_isReverted=!1,_triggers.forEach(t=>{if(t._subPinOffset&&t.pin){let prop=t.vars.horizontal?"offsetWidth":"offsetHeight",original=t.pin[prop];t.revert(!0,1),t.adjustPinSpacing(t.pin[prop]-original),t.refresh()}}),_clampingMax=1,_hideAllMarkers(!0),_triggers.forEach(t=>{let max=_maxScroll(t.scroller,t._dir),endClamp=t.vars.end==="max"||t._endClamp&&t.end>max,startClamp=t._startClamp&&t.start>=max;(endClamp||startClamp)&&t.setPositions(startClamp?max-1:t.start,endClamp?Math.max(startClamp?max:t.start+1,max):t.end,!0)}),_hideAllMarkers(!1),_clampingMax=0,refreshInits.forEach(result=>result&&result.render&&result.render(-1)),_scrollers.forEach(obj=>{_isFunction(obj)&&(obj.smooth&&requestAnimationFrame(()=>obj.target.style.scrollBehavior="smooth"),obj.rec&&obj(obj.rec))}),_clearScrollMemory(_scrollRestoration,1),_resizeDelay.pause(),_refreshID++,_refreshingAll=2,_updateAll(2),_triggers.forEach(t=>_isFunction(t.vars.onRefresh)&&t.vars.onRefresh(t)),_refreshingAll=ScrollTrigger.isRefreshing=!1,_dispatch("refresh")},_lastScroll=0,_direction=1,_primary,_updateAll=force=>{if(force===2||!_refreshingAll&&!_isReverted){ScrollTrigger.isUpdating=!0,_primary&&_primary.update(0);let l=_triggers.length,time=_getTime(),recordVelocity=time-_time1>=50,scroll=l&&_triggers[0].scroll();if(_direction=_lastScroll>scroll?-1:1,_refreshingAll||(_lastScroll=scroll),recordVelocity&&(_lastScrollTime&&!_pointerIsDown&&time-_lastScrollTime>200&&(_lastScrollTime=0,_dispatch("scrollEnd")),_time2=_time1,_time1=time),_direction<0){for(_i=l;_i-- >0;)_triggers[_i]&&_triggers[_i].update(0,recordVelocity);_direction=1}else for(_i=0;_i<l;_i++)_triggers[_i]&&_triggers[_i].update(0,recordVelocity);ScrollTrigger.isUpdating=!1}_rafID=0},_propNamesToCopy=[_left,_top,_bottom,_right,_margin+_Bottom,_margin+_Right,_margin+_Top,_margin+_Left,"display","flexShrink","float","zIndex","gridColumnStart","gridColumnEnd","gridRowStart","gridRowEnd","gridArea","justifySelf","alignSelf","placeSelf","order"],_stateProps=_propNamesToCopy.concat([_width,_height,"boxSizing","max"+_Width,"max"+_Height,"position",_margin,_padding,_padding+_Top,_padding+_Right,_padding+_Bottom,_padding+_Left]),_swapPinOut=(pin,spacer,state)=>{_setState(state);let cache=pin._gsap;if(cache.spacerIsNative)_setState(cache.spacerState);else if(pin._gsap.swappedIn){let parent=spacer.parentNode;parent&&(parent.insertBefore(pin,spacer),parent.removeChild(spacer))}pin._gsap.swappedIn=!1},_swapPinIn=(pin,spacer,cs,spacerState)=>{if(!pin._gsap.swappedIn){let i=_propNamesToCopy.length,spacerStyle=spacer.style,pinStyle=pin.style,p;for(;i--;)p=_propNamesToCopy[i],spacerStyle[p]=cs[p];spacerStyle.position=cs.position==="absolute"?"absolute":"relative",cs.display==="inline"&&(spacerStyle.display="inline-block"),pinStyle[_bottom]=pinStyle[_right]="auto",spacerStyle.flexBasis=cs.flexBasis||"auto",spacerStyle.overflow="visible",spacerStyle.boxSizing="border-box",spacerStyle[_width]=_getSize(pin,_horizontal)+_px,spacerStyle[_height]=_getSize(pin,_vertical)+_px,spacerStyle[_padding]=pinStyle[_margin]=pinStyle[_top]=pinStyle[_left]="0",_setState(spacerState),pinStyle[_width]=pinStyle["max"+_Width]=cs[_width],pinStyle[_height]=pinStyle["max"+_Height]=cs[_height],pinStyle[_padding]=cs[_padding],pin.parentNode!==spacer&&(pin.parentNode.insertBefore(spacer,pin),spacer.appendChild(pin)),pin._gsap.swappedIn=!0}},_capsExp=/([A-Z])/g,_setState=state=>{if(state){let style=state.t.style,l=state.length,i=0,p,value;for((state.t._gsap||gsap.core.getCache(state.t)).uncache=1;i<l;i+=2)value=state[i+1],p=state[i],value?style[p]=value:style[p]&&style.removeProperty(p.replace(_capsExp,"-$1").toLowerCase())}},_getState=element=>{let l=_stateProps.length,style=element.style,state=[],i=0;for(;i<l;i++)state.push(_stateProps[i],style[_stateProps[i]]);return state.t=element,state},_copyState=(state,override,omitOffsets)=>{let result=[],l=state.length,i=omitOffsets?8:0,p;for(;i<l;i+=2)p=state[i],result.push(p,p in override?override[p]:state[i+1]);return result.t=state.t,result},_winOffsets={left:0,top:0},_parsePosition=(value,trigger,scrollerSize,direction,scroll,marker,markerScroller,self,scrollerBounds,borderWidth,useFixedPosition,scrollerMax,containerAnimation,clampZeroProp)=>{_isFunction(value)&&(value=value(self)),_isString(value)&&value.substr(0,3)==="max"&&(value=scrollerMax+(value.charAt(4)==="="?_offsetToPx("0"+value.substr(3),scrollerSize):0));let time=containerAnimation?containerAnimation.time():0,p1,p2,element;if(containerAnimation&&containerAnimation.seek(0),isNaN(value)||(value=+value),_isNumber(value))containerAnimation&&(value=gsap.utils.mapRange(containerAnimation.scrollTrigger.start,containerAnimation.scrollTrigger.end,0,scrollerMax,value)),markerScroller&&_positionMarker(markerScroller,scrollerSize,direction,!0);else{_isFunction(trigger)&&(trigger=trigger(self));let offsets=(value||"0").split(" "),bounds,localOffset,globalOffset,display;element=_getTarget(trigger,self)||_body,bounds=_getBounds(element)||{},(!bounds||!bounds.left&&!bounds.top)&&_getComputedStyle(element).display==="none"&&(display=element.style.display,element.style.display="block",bounds=_getBounds(element),display?element.style.display=display:element.style.removeProperty("display")),localOffset=_offsetToPx(offsets[0],bounds[direction.d]),globalOffset=_offsetToPx(offsets[1]||"0",scrollerSize),value=bounds[direction.p]-scrollerBounds[direction.p]-borderWidth+localOffset+scroll-globalOffset,markerScroller&&_positionMarker(markerScroller,globalOffset,direction,scrollerSize-globalOffset<20||markerScroller._isStart&&globalOffset>20),scrollerSize-=scrollerSize-globalOffset}if(clampZeroProp&&(self[clampZeroProp]=value||-.001,value<0&&(value=0)),marker){let position=value+scrollerSize,isStart=marker._isStart;p1="scroll"+direction.d2,_positionMarker(marker,position,direction,isStart&&position>20||!isStart&&(useFixedPosition?Math.max(_body[p1],_docEl[p1]):marker.parentNode[p1])<=position+1),useFixedPosition&&(scrollerBounds=_getBounds(markerScroller),useFixedPosition&&(marker.style[direction.op.p]=scrollerBounds[direction.op.p]-direction.op.m-marker._offset+_px))}return containerAnimation&&element&&(p1=_getBounds(element),containerAnimation.seek(scrollerMax),p2=_getBounds(element),containerAnimation._caScrollDist=p1[direction.p]-p2[direction.p],value=value/containerAnimation._caScrollDist*scrollerMax),containerAnimation&&containerAnimation.seek(time),containerAnimation?value:Math.round(value)},_prefixExp=/(webkit|moz|length|cssText|inset)/i,_reparent=(element,parent,top,left)=>{if(element.parentNode!==parent){let style=element.style,p,cs;if(parent===_body){element._stOrig=style.cssText,cs=_getComputedStyle(element);for(p in cs)!+p&&!_prefixExp.test(p)&&cs[p]&&typeof style[p]=="string"&&p!=="0"&&(style[p]=cs[p]);style.top=top,style.left=left}else style.cssText=element._stOrig;gsap.core.getCache(element).uncache=1,parent.appendChild(element)}},_interruptionTracker=(getValueFunc,initialValue,onInterrupt)=>{let last1=initialValue,last2=last1;return value=>{let current=Math.round(getValueFunc());return current!==last1&&current!==last2&&Math.abs(current-last1)>3&&Math.abs(current-last2)>3&&(value=current,onInterrupt&&onInterrupt()),last2=last1,last1=value,value}},_shiftMarker=(marker,direction,value)=>{let vars={};vars[direction.p]="+="+value,gsap.set(marker,vars)},_getTweenCreator=(scroller,direction)=>{let getScroll=_getScrollFunc(scroller,direction),prop="_scroll"+direction.p2,getTween=(scrollTo,vars,initialValue,change1,change2)=>{let tween=getTween.tween,onComplete=vars.onComplete,modifiers={};initialValue=initialValue||getScroll();let checkForInterruption=_interruptionTracker(getScroll,initialValue,()=>{tween.kill(),getTween.tween=0});return change2=change1&&change2||0,change1=change1||scrollTo-initialValue,tween&&tween.kill(),vars[prop]=scrollTo,vars.modifiers=modifiers,modifiers[prop]=()=>checkForInterruption(initialValue+change1*tween.ratio+change2*tween.ratio*tween.ratio),vars.onUpdate=()=>{_scrollers.cache++,getTween.tween&&_updateAll()},vars.onComplete=()=>{getTween.tween=0,onComplete&&onComplete.call(tween)},tween=getTween.tween=gsap.to(scroller,vars),tween};return scroller[prop]=getScroll,getScroll.wheelHandler=()=>getTween.tween&&getTween.tween.kill()&&(getTween.tween=0),_addListener(scroller,"wheel",getScroll.wheelHandler),ScrollTrigger.isTouch&&_addListener(scroller,"touchmove",getScroll.wheelHandler),getTween};export class ScrollTrigger{constructor(vars,animation){_coreInitted||ScrollTrigger.register(gsap)||console.warn("Please gsap.registerPlugin(ScrollTrigger)"),_context(this),this.init(vars,animation)}init(vars,animation){if(this.progress=this.start=0,this.vars&&this.kill(!0,!0),!_enabled){this.update=this.refresh=this.kill=_passThrough;return}vars=_setDefaults(_isString(vars)||_isNumber(vars)||vars.nodeType?{trigger:vars}:vars,_defaults);let{onUpdate,toggleClass,id,onToggle,onRefresh,scrub,trigger,pin,pinSpacing,invalidateOnRefresh,anticipatePin,onScrubComplete,onSnapComplete,once,snap,pinReparent,pinSpacer,containerAnimation,fastScrollEnd,preventOverlaps}=vars,direction=vars.horizontal||vars.containerAnimation&&vars.horizontal!==!1?_horizontal:_vertical,isToggle=!scrub&&scrub!==0,scroller=_getTarget(vars.scroller||_win),scrollerCache=gsap.core.getCache(scroller),isViewport=_isViewport(scroller),useFixedPosition=("pinType"in vars?vars.pinType:_getProxyProp(scroller,"pinType")||isViewport&&"fixed")==="fixed",callbacks=[vars.onEnter,vars.onLeave,vars.onEnterBack,vars.onLeaveBack],toggleActions=isToggle&&vars.toggleActions.split(" "),markers="markers"in vars?vars.markers:_defaults.markers,borderWidth=isViewport?0:parseFloat(_getComputedStyle(scroller)["border"+direction.p2+_Width])||0,self=this,onRefreshInit=vars.onRefreshInit&&(()=>vars.onRefreshInit(self)),getScrollerSize=_getSizeFunc(scroller,isViewport,direction),getScrollerOffsets=_getOffsetsFunc(scroller,isViewport),lastSnap=0,lastRefresh=0,prevProgress=0,scrollFunc=_getScrollFunc(scroller,direction),tweenTo,pinCache,snapFunc,scroll1,scroll2,start,end,markerStart,markerEnd,markerStartTrigger,markerEndTrigger,markerVars,executingOnRefresh,change,pinOriginalState,pinActiveState,pinState,spacer,offset,pinGetter,pinSetter,pinStart,pinChange,spacingStart,spacerState,markerStartSetter,pinMoves,markerEndSetter,cs,snap1,snap2,scrubTween,scrubSmooth,snapDurClamp,snapDelayedCall,prevScroll,prevAnimProgress,caMarkerSetter,customRevertReturn;if(self._startClamp=self._endClamp=!1,self._dir=direction,anticipatePin*=45,self.scroller=scroller,self.scroll=containerAnimation?containerAnimation.time.bind(containerAnimation):scrollFunc,scroll1=scrollFunc(),self.vars=vars,animation=animation||vars.animation,"refreshPriority"in vars&&(_sort=1,vars.refreshPriority===-9999&&(_primary=self)),scrollerCache.tweenScroll=scrollerCache.tweenScroll||{top:_getTweenCreator(scroller,_vertical),left:_getTweenCreator(scroller,_horizontal)},self.tweenTo=tweenTo=scrollerCache.tweenScroll[direction.p],self.scrubDuration=value=>{scrubSmooth=_isNumber(value)&&value,scrubSmooth?scrubTween?scrubTween.duration(value):scrubTween=gsap.to(animation,{ease:"expo",totalProgress:"+=0",duration:scrubSmooth,paused:!0,onComplete:()=>onScrubComplete&&onScrubComplete(self)}):(scrubTween&&scrubTween.progress(1).kill(),scrubTween=0)},animation&&(animation.vars.lazy=!1,animation._initted&&!self.isReverted||animation.vars.immediateRender!==!1&&vars.immediateRender!==!1&&animation.duration()&&animation.render(0,!0,!0),self.animation=animation.pause(),animation.scrollTrigger=self,self.scrubDuration(scrub),snap1=0,id||(id=animation.vars.id)),snap&&((!_isObject(snap)||snap.push)&&(snap={snapTo:snap}),"scrollBehavior"in _body.style&&gsap.set(isViewport?[_body,_docEl]:scroller,{scrollBehavior:"auto"}),_scrollers.forEach(o=>_isFunction(o)&&o.target===(isViewport?_doc.scrollingElement||_docEl:scroller)&&(o.smooth=!1)),snapFunc=_isFunction(snap.snapTo)?snap.snapTo:snap.snapTo==="labels"?_getClosestLabel(animation):snap.snapTo==="labelsDirectional"?_getLabelAtDirection(animation):snap.directional!==!1?(value,st)=>_snapDirectional(snap.snapTo)(value,_getTime()-lastRefresh<500?0:st.direction):gsap.utils.snap(snap.snapTo),snapDurClamp=snap.duration||{min:.1,max:2},snapDurClamp=_isObject(snapDurClamp)?_clamp(snapDurClamp.min,snapDurClamp.max):_clamp(snapDurClamp,snapDurClamp),snapDelayedCall=gsap.delayedCall(snap.delay||scrubSmooth/2||.1,()=>{let scroll=scrollFunc(),refreshedRecently=_getTime()-lastRefresh<500,tween=tweenTo.tween;if((refreshedRecently||Math.abs(self.getVelocity())<10)&&!tween&&!_pointerIsDown&&lastSnap!==scroll){{let progress=(scroll-start)/change,totalProgress=animation&&!isToggle?animation.totalProgress():progress,velocity=refreshedRecently?0:(totalProgress-snap2)/(_getTime()-_time2)*1e3||0,change1=gsap.utils.clamp(-progress,1-progress,_abs(velocity/2)*velocity/.185),naturalEnd=progress+(snap.inertia===!1?0:change1),endValue=_clamp(0,1,snapFunc(naturalEnd,self)),endScroll=Math.round(start+endValue*change),{onStart,onInterrupt,onComplete}=snap;if(scroll<=end&&scroll>=start&&endScroll!==scroll){if(tween&&!tween._initted&&tween.data<=_abs(endScroll-scroll))return;snap.inertia===!1&&(change1=endValue-progress),tweenTo(endScroll,{duration:snapDurClamp(_abs(Math.max(_abs(naturalEnd-totalProgress),_abs(endValue-totalProgress))*.185/velocity/.05||0)),ease:snap.ease||"power3",data:_abs(endScroll-scroll),onInterrupt:()=>snapDelayedCall.restart(!0)&&onInterrupt&&onInterrupt(self),onComplete:()=>{self.update(),lastSnap=scrollFunc(),scrubTween&&animation&&animation.progress(endValue),snap1=snap2=animation&&!isToggle?animation.totalProgress():self.progress,onSnapComplete&&onSnapComplete(self),onComplete&&onComplete(self)}},scroll,change1*change,endScroll-scroll-change1*change),onStart&&onStart(self,tweenTo.tween)}}}else self.isActive&&lastSnap!==scroll&&snapDelayedCall.restart(!0)}).pause()),id&&(_ids[id]=self),trigger=self.trigger=_getTarget(trigger||pin!==!0&&pin),customRevertReturn=trigger&&trigger._gsap&&trigger._gsap.stRevert,customRevertReturn&&(customRevertReturn=customRevertReturn(self)),pin=pin===!0?trigger:_getTarget(pin),_isString(toggleClass)&&(toggleClass={targets:trigger,className:toggleClass}),pin&&(pinSpacing===!1||pinSpacing===_margin||(pinSpacing=!(!pinSpacing&&pin.parentNode&&pin.parentNode.style&&_getComputedStyle(pin.parentNode).display==="flex")&&_padding),self.pin=pin,pinCache=gsap.core.getCache(pin),pinCache.spacer?pinOriginalState=pinCache.pinState:(pinSpacer&&(pinSpacer=_getTarget(pinSpacer),pinSpacer&&!pinSpacer.nodeType&&(pinSpacer=pinSpacer.current||pinSpacer.nativeElement),pinCache.spacerIsNative=!!pinSpacer,pinSpacer&&(pinCache.spacerState=_getState(pinSpacer))),pinCache.spacer=spacer=pinSpacer||_doc.createElement("div"),spacer.classList.add("pin-spacer"),id&&spacer.classList.add("pin-spacer-"+id),pinCache.pinState=pinOriginalState=_getState(pin)),vars.force3D!==!1&&gsap.set(pin,{force3D:!0}),self.spacer=spacer=pinCache.spacer,cs=_getComputedStyle(pin),spacingStart=cs[pinSpacing+direction.os2],pinGetter=gsap.getProperty(pin),pinSetter=gsap.quickSetter(pin,direction.a,_px),_swapPinIn(pin,spacer,cs),pinState=_getState(pin)),markers){markerVars=_isObject(markers)?_setDefaults(markers,_markerDefaults):_markerDefaults,markerStartTrigger=_createMarker("scroller-start",id,scroller,direction,markerVars,0),markerEndTrigger=_createMarker("scroller-end",id,scroller,direction,markerVars,0,markerStartTrigger),offset=markerStartTrigger["offset"+direction.op.d2];let content=_getTarget(_getProxyProp(scroller,"content")||scroller);markerStart=this.markerStart=_createMarker("start",id,content,direction,markerVars,offset,0,containerAnimation),markerEnd=this.markerEnd=_createMarker("end",id,content,direction,markerVars,offset,0,containerAnimation),containerAnimation&&(caMarkerSetter=gsap.quickSetter([markerStart,markerEnd],direction.a,_px)),!useFixedPosition&&!(_proxies.length&&_getProxyProp(scroller,"fixedMarkers")===!0)&&(_makePositionable(isViewport?_body:scroller),gsap.set([markerStartTrigger,markerEndTrigger],{force3D:!0}),markerStartSetter=gsap.quickSetter(markerStartTrigger,direction.a,_px),markerEndSetter=gsap.quickSetter(markerEndTrigger,direction.a,_px))}if(containerAnimation){let oldOnUpdate=containerAnimation.vars.onUpdate,oldParams=containerAnimation.vars.onUpdateParams;containerAnimation.eventCallback("onUpdate",()=>{self.update(0,0,1),oldOnUpdate&&oldOnUpdate.apply(containerAnimation,oldParams||[])})}if(self.previous=()=>_triggers[_triggers.indexOf(self)-1],self.next=()=>_triggers[_triggers.indexOf(self)+1],self.revert=(revert,temp)=>{if(!temp)return self.kill(!0);let r=revert!==!1||!self.enabled,prevRefreshing=_refreshing;r!==self.isReverted&&(r&&(prevScroll=Math.max(scrollFunc(),self.scroll.rec||0),prevProgress=self.progress,prevAnimProgress=animation&&animation.progress()),markerStart&&[markerStart,markerEnd,markerStartTrigger,markerEndTrigger].forEach(m=>m.style.display=r?"none":"block"),r&&(_refreshing=self,self.update(r)),pin&&(!pinReparent||!self.isActive)&&(r?_swapPinOut(pin,spacer,pinOriginalState):_swapPinIn(pin,spacer,_getComputedStyle(pin),spacerState)),r||self.update(r),_refreshing=prevRefreshing,self.isReverted=r)},self.refresh=(soft,force,position,pinOffset)=>{if((_refreshing||!self.enabled)&&!force)return;if(pin&&soft&&_lastScrollTime){_addListener(ScrollTrigger,"scrollEnd",_softRefresh);return}!_refreshingAll&&onRefreshInit&&onRefreshInit(self),_refreshing=self,tweenTo.tween&&!position&&(tweenTo.tween.kill(),tweenTo.tween=0),scrubTween&&scrubTween.pause(),invalidateOnRefresh&&animation&&animation.revert({kill:!1}).invalidate(),self.isReverted||self.revert(!0,!0),self._subPinOffset=!1;let size=getScrollerSize(),scrollerBounds=getScrollerOffsets(),max=containerAnimation?containerAnimation.duration():_maxScroll(scroller,direction),isFirstRefresh=change<=.01,offset=0,otherPinOffset=pinOffset||0,parsedEnd=_isObject(position)?position.end:vars.end,parsedEndTrigger=vars.endTrigger||trigger,parsedStart=_isObject(position)?position.start:vars.start||(vars.start===0||!trigger?0:pin?"0 0":"0 100%"),pinnedContainer=self.pinnedContainer=vars.pinnedContainer&&_getTarget(vars.pinnedContainer,self),triggerIndex=trigger&&Math.max(0,_triggers.indexOf(self))||0,i=triggerIndex,cs,bounds,scroll,isVertical,override,curTrigger,curPin,oppositeScroll,initted,revertedPins,forcedOverflow,markerStartOffset,markerEndOffset;for(markers&&_isObject(position)&&(markerStartOffset=gsap.getProperty(markerStartTrigger,direction.p),markerEndOffset=gsap.getProperty(markerEndTrigger,direction.p));i--;)curTrigger=_triggers[i],curTrigger.end||curTrigger.refresh(0,1)||(_refreshing=self),curPin=curTrigger.pin,curPin&&(curPin===trigger||curPin===pin||curPin===pinnedContainer)&&!curTrigger.isReverted&&(revertedPins||(revertedPins=[]),revertedPins.unshift(curTrigger),curTrigger.revert(!0,!0)),curTrigger!==_triggers[i]&&(triggerIndex--,i--);for(_isFunction(parsedStart)&&(parsedStart=parsedStart(self)),parsedStart=_parseClamp(parsedStart,"start",self),start=_parsePosition(parsedStart,trigger,size,direction,scrollFunc(),markerStart,markerStartTrigger,self,scrollerBounds,borderWidth,useFixedPosition,max,containerAnimation,self._startClamp&&"_startClamp")||(pin?-.001:0),_isFunction(parsedEnd)&&(parsedEnd=parsedEnd(self)),_isString(parsedEnd)&&!parsedEnd.indexOf("+=")&&(~parsedEnd.indexOf(" ")?parsedEnd=(_isString(parsedStart)?parsedStart.split(" ")[0]:"")+parsedEnd:(offset=_offsetToPx(parsedEnd.substr(2),size),parsedEnd=_isString(parsedStart)?parsedStart:(containerAnimation?gsap.utils.mapRange(0,containerAnimation.duration(),containerAnimation.scrollTrigger.start,containerAnimation.scrollTrigger.end,start):start)+offset,parsedEndTrigger=trigger)),parsedEnd=_parseClamp(parsedEnd,"end",self),end=Math.max(start,_parsePosition(parsedEnd||(parsedEndTrigger?"100% 0":max),parsedEndTrigger,size,direction,scrollFunc()+offset,markerEnd,markerEndTrigger,self,scrollerBounds,borderWidth,useFixedPosition,max,containerAnimation,self._endClamp&&"_endClamp"))||-.001,offset=0,i=triggerIndex;i--;)curTrigger=_triggers[i],curPin=curTrigger.pin,curPin&&curTrigger.start-curTrigger._pinPush<=start&&!containerAnimation&&curTrigger.end>0&&(cs=curTrigger.end-(self._startClamp?Math.max(0,curTrigger.start):curTrigger.start),(curPin===trigger&&curTrigger.start-curTrigger._pinPush<start||curPin===pinnedContainer)&&isNaN(parsedStart)&&(offset+=cs*(1-curTrigger.progress)),curPin===pin&&(otherPinOffset+=cs));if(start+=offset,end+=offset,self._startClamp&&(self._startClamp+=offset),self._endClamp&&!_refreshingAll&&(self._endClamp=end||-.001,end=Math.min(end,_maxScroll(scroller,direction))),change=end-start||(start-=.01)&&.001,isFirstRefresh&&(prevProgress=gsap.utils.clamp(0,1,gsap.utils.normalize(start,end,prevScroll))),self._pinPush=otherPinOffset,markerStart&&offset&&(cs={},cs[direction.a]="+="+offset,pinnedContainer&&(cs[direction.p]="-="+scrollFunc()),gsap.set([markerStart,markerEnd],cs)),pin&&!(_clampingMax&&self.end>=_maxScroll(scroller,direction)))cs=_getComputedStyle(pin),isVertical=direction===_vertical,scroll=scrollFunc(),pinStart=parseFloat(pinGetter(direction.a))+otherPinOffset,!max&&end>1&&(forcedOverflow=(isViewport?_doc.scrollingElement||_docEl:scroller).style,forcedOverflow={style:forcedOverflow,value:forcedOverflow["overflow"+direction.a.toUpperCase()]},isViewport&&_getComputedStyle(_body)["overflow"+direction.a.toUpperCase()]!=="scroll"&&(forcedOverflow.style["overflow"+direction.a.toUpperCase()]="scroll")),_swapPinIn(pin,spacer,cs),pinState=_getState(pin),bounds=_getBounds(pin,!0),oppositeScroll=useFixedPosition&&_getScrollFunc(scroller,isVertical?_horizontal:_vertical)(),pinSpacing&&(spacerState=[pinSpacing+direction.os2,change+otherPinOffset+_px],spacerState.t=spacer,i=pinSpacing===_padding?_getSize(pin,direction)+change+otherPinOffset:0,i&&(spacerState.push(direction.d,i+_px),spacer.style.flexBasis!=="auto"&&(spacer.style.flexBasis=i+_px)),_setState(spacerState),pinnedContainer&&_triggers.forEach(t=>{t.pin===pinnedContainer&&t.vars.pinSpacing!==!1&&(t._subPinOffset=!0)}),useFixedPosition&&scrollFunc(prevScroll)),useFixedPosition&&(override={top:bounds.top+(isVertical?scroll-start:oppositeScroll)+_px,left:bounds.left+(isVertical?oppositeScroll:scroll-start)+_px,boxSizing:"border-box",position:"fixed"},override[_width]=override["max"+_Width]=Math.ceil(bounds.width)+_px,override[_height]=override["max"+_Height]=Math.ceil(bounds.height)+_px,override[_margin]=override[_margin+_Top]=override[_margin+_Right]=override[_margin+_Bottom]=override[_margin+_Left]="0",override[_padding]=cs[_padding],override[_padding+_Top]=cs[_padding+_Top],override[_padding+_Right]=cs[_padding+_Right],override[_padding+_Bottom]=cs[_padding+_Bottom],override[_padding+_Left]=cs[_padding+_Left],pinActiveState=_copyState(pinOriginalState,override,pinReparent),_refreshingAll&&scrollFunc(0)),animation?(initted=animation._initted,_suppressOverwrites(1),animation.render(animation.duration(),!0,!0),pinChange=pinGetter(direction.a)-pinStart+change+otherPinOffset,pinMoves=Math.abs(change-pinChange)>1,useFixedPosition&&pinMoves&&pinActiveState.splice(pinActiveState.length-2,2),animation.render(0,!0,!0),initted||animation.invalidate(!0),animation.parent||animation.totalTime(animation.totalTime()),_suppressOverwrites(0)):pinChange=change,forcedOverflow&&(forcedOverflow.value?forcedOverflow.style["overflow"+direction.a.toUpperCase()]=forcedOverflow.value:forcedOverflow.style.removeProperty("overflow-"+direction.a));else if(trigger&&scrollFunc()&&!containerAnimation)for(bounds=trigger.parentNode;bounds&&bounds!==_body;)bounds._pinOffset&&(start-=bounds._pinOffset,end-=bounds._pinOffset),bounds=bounds.parentNode;revertedPins&&revertedPins.forEach(t=>t.revert(!1,!0)),self.start=start,self.end=end,scroll1=scroll2=_refreshingAll?prevScroll:scrollFunc(),!containerAnimation&&!_refreshingAll&&(scroll1<prevScroll&&scrollFunc(prevScroll),self.scroll.rec=0),self.revert(!1,!0),lastRefresh=_getTime(),snapDelayedCall&&(lastSnap=-1,snapDelayedCall.restart(!0)),_refreshing=0,animation&&isToggle&&(animation._initted||prevAnimProgress)&&animation.progress()!==prevAnimProgress&&animation.progress(prevAnimProgress||0,!0).render(animation.time(),!0,!0),(isFirstRefresh||prevProgress!==self.progress||containerAnimation)&&(animation&&!isToggle&&animation.totalProgress(containerAnimation&&start<-.001&&!prevProgress?gsap.utils.normalize(start,end,0):prevProgress,!0),self.progress=isFirstRefresh||(scroll1-start)/change===prevProgress?0:prevProgress),pin&&pinSpacing&&(spacer._pinOffset=Math.round(self.progress*pinChange)),scrubTween&&scrubTween.invalidate(),isNaN(markerStartOffset)||(markerStartOffset-=gsap.getProperty(markerStartTrigger,direction.p),markerEndOffset-=gsap.getProperty(markerEndTrigger,direction.p),_shiftMarker(markerStartTrigger,direction,markerStartOffset),_shiftMarker(markerStart,direction,markerStartOffset-(pinOffset||0)),_shiftMarker(markerEndTrigger,direction,markerEndOffset),_shiftMarker(markerEnd,direction,markerEndOffset-(pinOffset||0))),isFirstRefresh&&!_refreshingAll&&self.update(),onRefresh&&!_refreshingAll&&!executingOnRefresh&&(executingOnRefresh=!0,onRefresh(self),executingOnRefresh=!1)},self.getVelocity=()=>(scrollFunc()-scroll2)/(_getTime()-_time2)*1e3||0,self.endAnimation=()=>{_endAnimation(self.callbackAnimation),animation&&(scrubTween?scrubTween.progress(1):animation.paused()?isToggle||_endAnimation(animation,self.direction<0,1):_endAnimation(animation,animation.reversed()))},self.labelToScroll=label=>animation&&animation.labels&&(start||self.refresh()||start)+animation.labels[label]/animation.duration()*change||0,self.getTrailing=name=>{let i=_triggers.indexOf(self),a=self.direction>0?_triggers.slice(0,i).reverse():_triggers.slice(i+1);return(_isString(name)?a.filter(t=>t.vars.preventOverlaps===name):a).filter(t=>self.direction>0?t.end<=start:t.start>=end)},self.update=(reset,recordVelocity,forceFake)=>{if(containerAnimation&&!forceFake&&!reset)return;let scroll=_refreshingAll===!0?prevScroll:self.scroll(),p=reset?0:(scroll-start)/change,clipped=p<0?0:p>1?1:p||0,prevProgress=self.progress,isActive,wasActive,toggleState,action,stateChanged,toggled,isAtMax,isTakingAction;if(recordVelocity&&(scroll2=scroll1,scroll1=containerAnimation?scrollFunc():scroll,snap&&(snap2=snap1,snap1=animation&&!isToggle?animation.totalProgress():clipped)),anticipatePin&&!clipped&&pin&&!_refreshing&&!_startup&&_lastScrollTime&&start<scroll+(scroll-scroll2)/(_getTime()-_time2)*anticipatePin&&(clipped=1e-4),clipped!==prevProgress&&self.enabled){if(isActive=self.isActive=!!clipped&&clipped<1,wasActive=!!prevProgress&&prevProgress<1,toggled=isActive!==wasActive,stateChanged=toggled||!!clipped!==!!prevProgress,self.direction=clipped>prevProgress?1:-1,self.progress=clipped,stateChanged&&!_refreshing&&(toggleState=clipped&&!prevProgress?0:clipped===1?1:prevProgress===1?2:3,isToggle&&(action=!toggled&&toggleActions[toggleState+1]!=="none"&&toggleActions[toggleState+1]||toggleActions[toggleState],isTakingAction=animation&&(action==="complete"||action==="reset"||action in animation))),preventOverlaps&&(toggled||isTakingAction)&&(isTakingAction||scrub||!animation)&&(_isFunction(preventOverlaps)?preventOverlaps(self):self.getTrailing(preventOverlaps).forEach(t=>t.endAnimation())),isToggle||(scrubTween&&!_refreshing&&!_startup?(scrubTween._dp._time-scrubTween._start!==scrubTween._time&&scrubTween.render(scrubTween._dp._time-scrubTween._start),scrubTween.resetTo?scrubTween.resetTo("totalProgress",clipped,animation._tTime/animation._tDur):(scrubTween.vars.totalProgress=clipped,scrubTween.invalidate().restart())):animation&&animation.totalProgress(clipped,!!(_refreshing&&(lastRefresh||reset)))),pin)if(reset&&pinSpacing&&(spacer.style[pinSpacing+direction.os2]=spacingStart),useFixedPosition){if(stateChanged){if(isAtMax=!reset&&clipped>prevProgress&&end+1>scroll&&scroll+1>=_maxScroll(scroller,direction),pinReparent)if(!reset&&(isActive||isAtMax)){let bounds=_getBounds(pin,!0),offset=scroll-start;_reparent(pin,_body,bounds.top+(direction===_vertical?offset:0)+_px,bounds.left+(direction===_vertical?0:offset)+_px)}else _reparent(pin,spacer);_setState(isActive||isAtMax?pinActiveState:pinState),pinMoves&&clipped<1&&isActive||pinSetter(pinStart+(clipped===1&&!isAtMax?pinChange:0))}}else pinSetter(_round(pinStart+pinChange*clipped));snap&&!tweenTo.tween&&!_refreshing&&!_startup&&snapDelayedCall.restart(!0),toggleClass&&(toggled||once&&clipped&&(clipped<1||!_limitCallbacks))&&_toArray(toggleClass.targets).forEach(el=>el.classList[isActive||once?"add":"remove"](toggleClass.className)),onUpdate&&!isToggle&&!reset&&onUpdate(self),stateChanged&&!_refreshing?(isToggle&&(isTakingAction&&(action==="complete"?animation.pause().totalProgress(1):action==="reset"?animation.restart(!0).pause():action==="restart"?animation.restart(!0):animation[action]()),onUpdate&&onUpdate(self)),(toggled||!_limitCallbacks)&&(onToggle&&toggled&&_callback(self,onToggle),callbacks[toggleState]&&_callback(self,callbacks[toggleState]),once&&(clipped===1?self.kill(!1,1):callbacks[toggleState]=0),toggled||(toggleState=clipped===1?1:3,callbacks[toggleState]&&_callback(self,callbacks[toggleState]))),fastScrollEnd&&!isActive&&Math.abs(self.getVelocity())>(_isNumber(fastScrollEnd)?fastScrollEnd:2500)&&(_endAnimation(self.callbackAnimation),scrubTween?scrubTween.progress(1):_endAnimation(animation,action==="reverse"?1:!clipped,1))):isToggle&&onUpdate&&!_refreshing&&onUpdate(self)}if(markerEndSetter){let n=containerAnimation?scroll/containerAnimation.duration()*(containerAnimation._caScrollDist||0):scroll;markerStartSetter(n+(markerStartTrigger._isFlipped?1:0)),markerEndSetter(n)}caMarkerSetter&&caMarkerSetter(-scroll/containerAnimation.duration()*(containerAnimation._caScrollDist||0))},self.enable=(reset,refresh)=>{self.enabled||(self.enabled=!0,_addListener(scroller,"resize",_onResize),isViewport||_addListener(scroller,"scroll",_onScroll),onRefreshInit&&_addListener(ScrollTrigger,"refreshInit",onRefreshInit),reset!==!1&&(self.progress=prevProgress=0,scroll1=scroll2=lastSnap=scrollFunc()),refresh!==!1&&self.refresh())},self.getTween=snap=>snap&&tweenTo?tweenTo.tween:scrubTween,self.setPositions=(newStart,newEnd,keepClamp,pinOffset)=>{if(containerAnimation){let st=containerAnimation.scrollTrigger,duration=containerAnimation.duration(),change=st.end-st.start;newStart=st.start+change*newStart/duration,newEnd=st.start+change*newEnd/duration}self.refresh(!1,!1,{start:_keepClamp(newStart,keepClamp&&!!self._startClamp),end:_keepClamp(newEnd,keepClamp&&!!self._endClamp)},pinOffset),self.update()},self.adjustPinSpacing=amount=>{if(spacerState&&amount){let i=spacerState.indexOf(direction.d)+1;spacerState[i]=parseFloat(spacerState[i])+amount+_px,spacerState[1]=parseFloat(spacerState[1])+amount+_px,_setState(spacerState)}},self.disable=(reset,allowAnimation)=>{if(self.enabled&&(reset!==!1&&self.revert(!0,!0),self.enabled=self.isActive=!1,allowAnimation||scrubTween&&scrubTween.pause(),prevScroll=0,pinCache&&(pinCache.uncache=1),onRefreshInit&&_removeListener(ScrollTrigger,"refreshInit",onRefreshInit),snapDelayedCall&&(snapDelayedCall.pause(),tweenTo.tween&&tweenTo.tween.kill()&&(tweenTo.tween=0)),!isViewport)){let i=_triggers.length;for(;i--;)if(_triggers[i].scroller===scroller&&_triggers[i]!==self)return;_removeListener(scroller,"resize",_onResize),isViewport||_removeListener(scroller,"scroll",_onScroll)}},self.kill=(revert,allowAnimation)=>{self.disable(revert,allowAnimation),scrubTween&&!allowAnimation&&scrubTween.kill(),id&&delete _ids[id];let i=_triggers.indexOf(self);i>=0&&_triggers.splice(i,1),i===_i&&_direction>0&&_i--,i=0,_triggers.forEach(t=>t.scroller===self.scroller&&(i=1)),i||_refreshingAll||(self.scroll.rec=0),animation&&(animation.scrollTrigger=null,revert&&animation.revert({kill:!1}),allowAnimation||animation.kill()),markerStart&&[markerStart,markerEnd,markerStartTrigger,markerEndTrigger].forEach(m=>m.parentNode&&m.parentNode.removeChild(m)),_primary===self&&(_primary=0),pin&&(pinCache&&(pinCache.uncache=1),i=0,_triggers.forEach(t=>t.pin===pin&&i++),i||(pinCache.spacer=0)),vars.onKill&&vars.onKill(self)},_triggers.push(self),self.enable(!1,!1),customRevertReturn&&customRevertReturn(self),animation&&animation.add&&!change){let updateFunc=self.update;self.update=()=>{self.update=updateFunc,start||end||self.refresh()},gsap.delayedCall(.01,self.update),change=.01,start=end=0}else self.refresh();pin&&_queueRefreshAll()}static register(core){return _coreInitted||(gsap=core||_getGSAP(),_windowExists()&&window.document&&ScrollTrigger.enable(),_coreInitted=_enabled),_coreInitted}static defaults(config){if(config)for(let p in config)_defaults[p]=config[p];return _defaults}static disable(reset,kill){_enabled=0,_triggers.forEach(trigger=>trigger[kill?"kill":"disable"](reset)),_removeListener(_win,"wheel",_onScroll),_removeListener(_doc,"scroll",_onScroll),clearInterval(_syncInterval),_removeListener(_doc,"touchcancel",_passThrough),_removeListener(_body,"touchstart",_passThrough),_multiListener(_removeListener,_doc,"pointerdown,touchstart,mousedown",_pointerDownHandler),_multiListener(_removeListener,_doc,"pointerup,touchend,mouseup",_pointerUpHandler),_resizeDelay.kill(),_iterateAutoRefresh(_removeListener);for(let i=0;i<_scrollers.length;i+=3)_wheelListener(_removeListener,_scrollers[i],_scrollers[i+1]),_wheelListener(_removeListener,_scrollers[i],_scrollers[i+2])}static enable(){if(_win=window,_doc=document,_docEl=_doc.documentElement,_body=_doc.body,gsap&&(_toArray=gsap.utils.toArray,_clamp=gsap.utils.clamp,_context=gsap.core.context||_passThrough,_suppressOverwrites=gsap.core.suppressOverwrites||_passThrough,_scrollRestoration=_win.history.scrollRestoration||"auto",_lastScroll=_win.pageYOffset,gsap.core.globals("ScrollTrigger",ScrollTrigger),_body)){_enabled=1,_div100vh=document.createElement("div"),_div100vh.style.height="100vh",_div100vh.style.position="absolute",_refresh100vh(),_rafBugFix(),Observer.register(gsap),ScrollTrigger.isTouch=Observer.isTouch,_fixIOSBug=Observer.isTouch&&/(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),_addListener(_win,"wheel",_onScroll),_root=[_win,_doc,_docEl,_body],gsap.matchMedia?(ScrollTrigger.matchMedia=vars=>{let mm=gsap.matchMedia(),p;for(p in vars)mm.add(p,vars[p]);return mm},gsap.addEventListener("matchMediaInit",()=>_revertAll()),gsap.addEventListener("matchMediaRevert",()=>_revertRecorded()),gsap.addEventListener("matchMedia",()=>{_refreshAll(0,1),_dispatch("matchMedia")}),gsap.matchMedia("(orientation: portrait)",()=>(_setBaseDimensions(),_setBaseDimensions))):console.warn("Requires GSAP 3.11.0 or later"),_setBaseDimensions(),_addListener(_doc,"scroll",_onScroll);let bodyStyle=_body.style,border=bodyStyle.borderTopStyle,AnimationProto=gsap.core.Animation.prototype,bounds,i;AnimationProto.revert||Object.defineProperty(AnimationProto,"revert",{value:function(){return this.time(-.01,!0)}}),bodyStyle.borderTopStyle="solid",bounds=_getBounds(_body),_vertical.m=Math.round(bounds.top+_vertical.sc())||0,_horizontal.m=Math.round(bounds.left+_horizontal.sc())||0,border?bodyStyle.borderTopStyle=border:bodyStyle.removeProperty("border-top-style"),_syncInterval=setInterval(_sync,250),gsap.delayedCall(.5,()=>_startup=0),_addListener(_doc,"touchcancel",_passThrough),_addListener(_body,"touchstart",_passThrough),_multiListener(_addListener,_doc,"pointerdown,touchstart,mousedown",_pointerDownHandler),_multiListener(_addListener,_doc,"pointerup,touchend,mouseup",_pointerUpHandler),_transformProp=gsap.utils.checkPrefix("transform"),_stateProps.push(_transformProp),_coreInitted=_getTime(),_resizeDelay=gsap.delayedCall(.2,_refreshAll).pause(),_autoRefresh=[_doc,"visibilitychange",()=>{let w=_win.innerWidth,h=_win.innerHeight;_doc.hidden?(_prevWidth=w,_prevHeight=h):(_prevWidth!==w||_prevHeight!==h)&&_onResize()},_doc,"DOMContentLoaded",_refreshAll,_win,"load",_refreshAll,_win,"resize",_onResize],_iterateAutoRefresh(_addListener),_triggers.forEach(trigger=>trigger.enable(0,1));for(i=0;i<_scrollers.length;i+=3)_wheelListener(_removeListener,_scrollers[i],_scrollers[i+1]),_wheelListener(_removeListener,_scrollers[i],_scrollers[i+2])}}static config(vars){"limitCallbacks"in vars&&(_limitCallbacks=!!vars.limitCallbacks);let ms=vars.syncInterval;ms&&clearInterval(_syncInterval)||(_syncInterval=ms)&&setInterval(_sync,ms),"ignoreMobileResize"in vars&&(_ignoreMobileResize=ScrollTrigger.isTouch===1&&vars.ignoreMobileResize),"autoRefreshEvents"in vars&&(_iterateAutoRefresh(_removeListener)||_iterateAutoRefresh(_addListener,vars.autoRefreshEvents||"none"),_ignoreResize=(vars.autoRefreshEvents+"").indexOf("resize")===-1)}static scrollerProxy(target,vars){let t=_getTarget(target),i=_scrollers.indexOf(t),isViewport=_isViewport(t);~i&&_scrollers.splice(i,isViewport?6:2),vars&&(isViewport?_proxies.unshift(_win,vars,_body,vars,_docEl,vars):_proxies.unshift(t,vars))}static clearMatchMedia(query){_triggers.forEach(t=>t._ctx&&t._ctx.query===query&&t._ctx.kill(!0,!0))}static isInViewport(element,ratio,horizontal){let bounds=(_isString(element)?_getTarget(element):element).getBoundingClientRect(),offset=bounds[horizontal?_width:_height]*ratio||0;return horizontal?bounds.right-offset>0&&bounds.left+offset<_win.innerWidth:bounds.bottom-offset>0&&bounds.top+offset<_win.innerHeight}static positionInViewport(element,referencePoint,horizontal){_isString(element)&&(element=_getTarget(element));let bounds=element.getBoundingClientRect(),size=bounds[horizontal?_width:_height],offset=referencePoint==null?size/2:referencePoint in _keywords?_keywords[referencePoint]*size:~referencePoint.indexOf("%")?parseFloat(referencePoint)*size/100:parseFloat(referencePoint)||0;return horizontal?(bounds.left+offset)/_win.innerWidth:(bounds.top+offset)/_win.innerHeight}static killAll(allowListeners){if(_triggers.slice(0).forEach(t=>t.vars.id!=="ScrollSmoother"&&t.kill()),allowListeners!==!0){let listeners=_listeners.killAll||[];_listeners={},listeners.forEach(f=>f())}}}ScrollTrigger.version="3.12.4",ScrollTrigger.saveStyles=targets=>targets?_toArray(targets).forEach(target=>{if(target&&target.style){let i=_savedStyles.indexOf(target);i>=0&&_savedStyles.splice(i,5),_savedStyles.push(target,target.style.cssText,target.getBBox&&target.getAttribute("transform"),gsap.core.getCache(target),_context())}}):_savedStyles,ScrollTrigger.revert=(soft,media)=>_revertAll(!soft,media),ScrollTrigger.create=(vars,animation)=>new ScrollTrigger(vars,animation),ScrollTrigger.refresh=safe=>safe?_onResize():(_coreInitted||ScrollTrigger.register())&&_refreshAll(!0),ScrollTrigger.update=force=>++_scrollers.cache&&_updateAll(force===!0?2:0),ScrollTrigger.clearScrollMemory=_clearScrollMemory,ScrollTrigger.maxScroll=(element,horizontal)=>_maxScroll(element,horizontal?_horizontal:_vertical),ScrollTrigger.getScrollFunc=(element,horizontal)=>_getScrollFunc(_getTarget(element),horizontal?_horizontal:_vertical),ScrollTrigger.getById=id=>_ids[id],ScrollTrigger.getAll=()=>_triggers.filter(t=>t.vars.id!=="ScrollSmoother"),ScrollTrigger.isScrolling=()=>!!_lastScrollTime,ScrollTrigger.snapDirectional=_snapDirectional,ScrollTrigger.addEventListener=(type,callback)=>{let a=_listeners[type]||(_listeners[type]=[]);~a.indexOf(callback)||a.push(callback)},ScrollTrigger.removeEventListener=(type,callback)=>{let a=_listeners[type],i=a&&a.indexOf(callback);i>=0&&a.splice(i,1)},ScrollTrigger.batch=(targets,vars)=>{let result=[],varsCopy={},interval=vars.interval||.016,batchMax=vars.batchMax||1e9,proxyCallback=(type,callback)=>{let elements=[],triggers=[],delay=gsap.delayedCall(interval,()=>{callback(elements,triggers),elements=[],triggers=[]}).pause();return self=>{elements.length||delay.restart(!0),elements.push(self.trigger),triggers.push(self),batchMax<=elements.length&&delay.progress(1)}},p;for(p in vars)varsCopy[p]=p.substr(0,2)==="on"&&_isFunction(vars[p])&&p!=="onRefreshInit"?proxyCallback(p,vars[p]):vars[p];return _isFunction(batchMax)&&(batchMax=batchMax(),_addListener(ScrollTrigger,"refresh",()=>batchMax=vars.batchMax())),_toArray(targets).forEach(target=>{let config={};for(p in varsCopy)config[p]=varsCopy[p];config.trigger=target,result.push(ScrollTrigger.create(config))}),result};let _clampScrollAndGetDurationMultiplier=(scrollFunc,current,end,max)=>(current>max?scrollFunc(max):current<0&&scrollFunc(0),end>max?(max-current)/(end-current):end<0?current/(current-end):1),_allowNativePanning=(target,direction)=>{direction===!0?target.style.removeProperty("touch-action"):target.style.touchAction=direction===!0?"auto":direction?"pan-"+direction+(Observer.isTouch?" pinch-zoom":""):"none",target===_docEl&&_allowNativePanning(_body,direction)},_overflow={auto:1,scroll:1},_nestedScroll=({event,target,axis})=>{let node=(event.changedTouches?event.changedTouches[0]:event).target,cache=node._gsap||gsap.core.getCache(node),time=_getTime(),cs;if(!cache._isScrollT||time-cache._isScrollT>2e3){for(;node&&node!==_body&&(node.scrollHeight<=node.clientHeight&&node.scrollWidth<=node.clientWidth||!_overflow[(cs=_getComputedStyle(node)).overflowY]&&!_overflow[cs.overflowX]);)node=node.parentNode;cache._isScroll=node&&node!==target&&!_isViewport(node)&&(_overflow[(cs=_getComputedStyle(node)).overflowY]||_overflow[cs.overflowX]),cache._isScrollT=time}(cache._isScroll||axis==="x")&&(event.stopPropagation(),event._gsapAllow=!0)},_inputObserver=(target,type,inputs,nested)=>Observer.create({target,capture:!0,debounce:!1,lockAxis:!0,type,onWheel:nested=nested&&_nestedScroll,onPress:nested,onDrag:nested,onScroll:nested,onEnable:()=>inputs&&_addListener(_doc,Observer.eventTypes[0],_captureInputs,!1,!0),onDisable:()=>_removeListener(_doc,Observer.eventTypes[0],_captureInputs,!0)}),_inputExp=/(input|label|select|textarea)/i,_inputIsFocused,_captureInputs=e=>{let isInput=_inputExp.test(e.target.tagName);(isInput||_inputIsFocused)&&(e._gsapAllow=!0,_inputIsFocused=isInput)},_getScrollNormalizer=vars=>{_isObject(vars)||(vars={}),vars.preventDefault=vars.isNormalizer=vars.allowClicks=!0,vars.type||(vars.type="wheel,touch"),vars.debounce=!!vars.debounce,vars.id=vars.id||"normalizer";let{normalizeScrollX,momentum,allowNestedScroll,onRelease}=vars,self,maxY,target=_getTarget(vars.target)||_docEl,smoother=gsap.core.globals().ScrollSmoother,smootherInstance=smoother&&smoother.get(),content=_fixIOSBug&&(vars.content&&_getTarget(vars.content)||smootherInstance&&vars.content!==!1&&!smootherInstance.smooth()&&smootherInstance.content()),scrollFuncY=_getScrollFunc(target,_vertical),scrollFuncX=_getScrollFunc(target,_horizontal),scale=1,initialScale=(Observer.isTouch&&_win.visualViewport?_win.visualViewport.scale*_win.visualViewport.width:_win.outerWidth)/_win.innerWidth,wheelRefresh=0,resolveMomentumDuration=_isFunction(momentum)?()=>momentum(self):()=>momentum||2.8,lastRefreshID,skipTouchMove,inputObserver=_inputObserver(target,vars.type,!0,allowNestedScroll),resumeTouchMove=()=>skipTouchMove=!1,scrollClampX=_passThrough,scrollClampY=_passThrough,updateClamps=()=>{maxY=_maxScroll(target,_vertical),scrollClampY=_clamp(_fixIOSBug?1:0,maxY),normalizeScrollX&&(scrollClampX=_clamp(0,_maxScroll(target,_horizontal))),lastRefreshID=_refreshID},removeContentOffset=()=>{content._gsap.y=_round(parseFloat(content._gsap.y)+scrollFuncY.offset)+"px",content.style.transform="matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, "+parseFloat(content._gsap.y)+", 0, 1)",scrollFuncY.offset=scrollFuncY.cacheID=0},ignoreDrag=()=>{if(skipTouchMove){requestAnimationFrame(resumeTouchMove);let offset=_round(self.deltaY/2),scroll=scrollClampY(scrollFuncY.v-offset);if(content&&scroll!==scrollFuncY.v+scrollFuncY.offset){scrollFuncY.offset=scroll-scrollFuncY.v;let y=_round((parseFloat(content&&content._gsap.y)||0)-scrollFuncY.offset);content.style.transform="matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, "+y+", 0, 1)",content._gsap.y=y+"px",scrollFuncY.cacheID=_scrollers.cache,_updateAll()}return!0}scrollFuncY.offset&&removeContentOffset(),skipTouchMove=!0},tween,startScrollX,startScrollY,onStopDelayedCall,onResize=()=>{updateClamps(),tween.isActive()&&tween.vars.scrollY>maxY&&(scrollFuncY()>maxY?tween.progress(1)&&scrollFuncY(maxY):tween.resetTo("scrollY",maxY))};return content&&gsap.set(content,{y:"+=0"}),vars.ignoreCheck=e=>_fixIOSBug&&e.type==="touchmove"&&ignoreDrag(e)||scale>1.05&&e.type!=="touchstart"||self.isGesturing||e.touches&&e.touches.length>1,vars.onPress=()=>{skipTouchMove=!1;let prevScale=scale;scale=_round((_win.visualViewport&&_win.visualViewport.scale||1)/initialScale),tween.pause(),prevScale!==scale&&_allowNativePanning(target,scale>1.01||!normalizeScrollX&&"x"),startScrollX=scrollFuncX(),startScrollY=scrollFuncY(),updateClamps(),lastRefreshID=_refreshID},vars.onRelease=vars.onGestureStart=(self,wasDragging)=>{if(scrollFuncY.offset&&removeContentOffset(),wasDragging){_scrollers.cache++;let dur=resolveMomentumDuration(),currentScroll,endScroll;normalizeScrollX&&(currentScroll=scrollFuncX(),endScroll=currentScroll+dur*.05*-self.velocityX/.227,dur*=_clampScrollAndGetDurationMultiplier(scrollFuncX,currentScroll,endScroll,_maxScroll(target,_horizontal)),tween.vars.scrollX=scrollClampX(endScroll)),currentScroll=scrollFuncY(),endScroll=currentScroll+dur*.05*-self.velocityY/.227,dur*=_clampScrollAndGetDurationMultiplier(scrollFuncY,currentScroll,endScroll,_maxScroll(target,_vertical)),tween.vars.scrollY=scrollClampY(endScroll),tween.invalidate().duration(dur).play(.01),(_fixIOSBug&&tween.vars.scrollY>=maxY||currentScroll>=maxY-1)&&gsap.to({},{onUpdate:onResize,duration:dur})}else onStopDelayedCall.restart(!0);onRelease&&onRelease(self)},vars.onWheel=()=>{tween._ts&&tween.pause(),_getTime()-wheelRefresh>1e3&&(lastRefreshID=0,wheelRefresh=_getTime())},vars.onChange=(self,dx,dy,xArray,yArray)=>{if(_refreshID!==lastRefreshID&&updateClamps(),dx&&normalizeScrollX&&scrollFuncX(scrollClampX(xArray[2]===dx?startScrollX+(self.startX-self.x):scrollFuncX()+dx-xArray[1])),dy){scrollFuncY.offset&&removeContentOffset();let isTouch=yArray[2]===dy,y=isTouch?startScrollY+self.startY-self.y:scrollFuncY()+dy-yArray[1],yClamped=scrollClampY(y);isTouch&&y!==yClamped&&(startScrollY+=yClamped-y),scrollFuncY(yClamped)}(dy||dx)&&_updateAll()},vars.onEnable=()=>{_allowNativePanning(target,!normalizeScrollX&&"x"),ScrollTrigger.addEventListener("refresh",onResize),_addListener(_win,"resize",onResize),scrollFuncY.smooth&&(scrollFuncY.target.style.scrollBehavior="auto",scrollFuncY.smooth=scrollFuncX.smooth=!1),inputObserver.enable()},vars.onDisable=()=>{_allowNativePanning(target,!0),_removeListener(_win,"resize",onResize),ScrollTrigger.removeEventListener("refresh",onResize),inputObserver.kill()},vars.lockAxis=vars.lockAxis!==!1,self=new Observer(vars),self.iOS=_fixIOSBug,_fixIOSBug&&!scrollFuncY()&&scrollFuncY(1),_fixIOSBug&&gsap.ticker.add(_passThrough),onStopDelayedCall=self._dc,tween=gsap.to(self,{ease:"power4",paused:!0,scrollX:normalizeScrollX?"+=0.1":"+=0",scrollY:"+=0.1",modifiers:{scrollY:_interruptionTracker(scrollFuncY,scrollFuncY(),()=>tween.pause())},onUpdate:_updateAll,onComplete:onStopDelayedCall.vars.onComplete}),self};ScrollTrigger.sort=func=>_triggers.sort(func||((a,b)=>(a.vars.refreshPriority||0)*-1e6+a.start-(b.start+(b.vars.refreshPriority||0)*-1e6))),ScrollTrigger.observe=vars=>new Observer(vars),ScrollTrigger.normalizeScroll=vars=>{if(typeof vars=="undefined")return _normalizer;if(vars===!0&&_normalizer)return _normalizer.enable();if(vars===!1){_normalizer&&_normalizer.kill(),_normalizer=vars;return}let normalizer=vars instanceof Observer?vars:_getScrollNormalizer(vars);return _normalizer&&_normalizer.target===normalizer.target&&_normalizer.kill(),_isViewport(normalizer.target)&&(_normalizer=normalizer),normalizer},ScrollTrigger.core={_getVelocityProp,_inputObserver,_scrollers,_proxies,bridge:{ss:()=>{_lastScrollTime||_dispatch("scrollStart"),_lastScrollTime=_getTime()},ref:()=>_refreshing}},_getGSAP()&&gsap.registerPlugin(ScrollTrigger);export{ScrollTrigger as default}